#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  sBS,            sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  FL,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  FR,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  BR,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  BL,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           BS,            tmotorVex393HighSpeed_HBridge, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port2,           FL,            tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           FR,            tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           BL,            tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           BR,            tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

//Prototype Functions
bool compare(int base, int comp){

	bool same = false;

	//writeDebugStreamLine(" Base: %i", base);
	//writeDebugStreamLine("Comp: %i", comp);

	if(comp > (base - 3) && comp < (base + 3)){

		same = true;
	}//if


	return same;
}//compare




task autonomous()
{

  //Sets motor encoder value equal to zero
	nMotorEncoder(FL) = 0;
	nMotorEncoder(FR) = 0;
	nMotorEncoder(BL) = 0;
	nMotorEncoder(BR) = 0;
	SensorValue[sBS] = 0;

	bool BSdone = false;
	bool FLdone = false;
	bool FRdone = false;
	bool BLdone = false;
	bool BRdone = false;

	int totalSteps = 9;
	int ports = 5;




int auto[9][5] = { {0,0,0,0,0},
{0,1280,-1205,1269,-1200},
{0,1309,-1236,1297,-1226},
{0,824,-1781,827,-1784},
{0,804,-1798,809,-1803},
{0,2249,-3199,2233,-3187},
{0,2309,-3252,2294,-3237},
{0,2947,-2851,2900,-2828},
{0,4013,-3863,3950,-3834},
};





  int motorsFinished = 0;

  for(int step = 0; step < totalSteps; step++){

    BSdone = false;
	  FLdone = false;
	  FRdone = false;
	  BLdone = false;
	  BRdone = false;

  writeDebugStreamLine("");
  writeDebugStreamLine("Step: %i", step);
  writeDebugStreamLine("");


  	while(motorsFinished != ports){

      //BS if
      if(!BSdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(auto[step][0], SensorValue[sBS])){
          //Stops motor
          motor[BS] = 0;
          //Says this motor is done to prevent entering this loop and creating a false positive
          BSdone = true;
          //Increases total of motors done
          motorsFinished++;
          //Breaks out of this if so the motor doesn't restart
          goto BSend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(SensorValue[sBS] > auto[step][0]){
          motor[BS] = -30;
          //If the target value os above the motor value it will spin foreward
        }else if(SensorValue[sBS] < auto[step][0]){
          motor[BS] = 30;
        }

        //Where the goto comes to
        BSend:;

      }//BS if






  		//FL if
      if(!FLdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(auto[step][1], nMotorEncoder(FL))){
          //Stops motor
          motor[FL] = 0;
          //Says this motor is done to prevent entering this loop and creating a false positive
          FLdone = true;
          //Increases total of motors done
          motorsFinished++;
          //Breaks out of this if so the motor doesn't restart
          goto FLend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(nMotorEncoder(FL) > auto[step][1]){
          motor[FL] = -60;
          //If the target value os above the motor value it will spin foreward
        }else if(nMotorEncoder(FL) < auto[step][1]){
          motor[FL] = 60;
        }

        //Where the goto comes to
        FLend:;

      }//FL if








      //FR if
      if(!FRdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(auto[step][2], nMotorEncoder(FR))){
          //Stops motor
          motor[FR] = 0;
          //Says this motor is done to prevent entering this loop and creating a false positive
          FRdone = true;
          //Increases total of motors done
          motorsFinished++;
          //Breaks out of this if so the motor doesn't restart
          goto FRend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(nMotorEncoder(FR) > auto[step][2]){
          motor[FR] = -60;
          //If the target value os above the motor value it will spin foreward
        }else if(nMotorEncoder(FR) < auto[step][2]){
          motor[FR] = 60;
        }

        //Where the goto comes to
        FRend:;

      }//FR if







      //BL if
      if(!BLdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(auto[step][3], nMotorEncoder(BL))){
          //Stops motor
          motor[BL] = 0;
          //Says this motor is done to prevent entering this loop and creating a false positive
          BLdone = true;
          //Increases total of motors done
          motorsFinished++;
          //Breaks out of this if so the motor doesn't restart
          goto BLend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(nMotorEncoder(BL) > auto[step][3]){
          motor[BL] = -60;
          //If the target value os above the motor value it will spin foreward
        }else if(nMotorEncoder(BL) < auto[step][3]){
          motor[BL] = 60;
        }

        //Where the goto comes to
        BLend:;

      }//bL if







      //BR if
      if(!BRdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(auto[step][4], nMotorEncoder(BR))){
          //Stops motor
          motor[BR] = 0;
          //Says this motor is done to prevent entering this loop and creating a false positive
          BRdone = true;
          //Increases total of motors done
          motorsFinished++;
          //Breaks out of this if so the motor doesn't restart
          goto BRend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(nMotorEncoder(BR) > auto[step][4]){
          motor[BR] = -60;
          //If the target value os above the motor value it will spin foreward
        }else if(nMotorEncoder(BR) < auto[step][4]){
          motor[BR] = 60;
        }

        //Where the goto comes to
        BRend:;

      }//BR if





    }//While

    motorsFinished = 0;
    //writeDebugStreamLine("New Step");
  }//for

  //writeDebugStreamLine("OUT");

}//autonomous

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{

	//boolean values representing if the the button is pressed or not
	int up8U = 0;
	int up8D = 0;
	bool upCh3 = false;
	bool downCh3 = false;
	bool upCh2 = false;
	bool downCh2 = false;

	//Varible that will hold if any button presses have changed
	bool change = false;

  //Sets motor encoder value equal to zero
	nMotorEncoder(FL) = 0;
	nMotorEncoder(FR) = 0;
	nMotorEncoder(BL) = 0;
	nMotorEncoder(BR) = 0;
	SensorValue[sBS] = 0;
	//Counts iterations through while loop so there isn't a constant stream of output data
	int iterations = 0;

  while (true)
  {

  //Driving code in tank drive
  /*motor[FR] = -vexRT[Ch2];
  motor[BR] = -vexRT[Ch2];
  motor[FL] = vexRT[Ch3];
  motor[BL] = vexRT[Ch3];*/

  //The driving is code this way so that it only drives at one speed and when the axis are full. This simplifies recording the autonomous because you don't have
  //to worry about varible speed

  //Driving for Ch2 axis
  if(vexRT[Ch2] > 100){
		motor[FR] = -30;//The motor power is 60 so the bot is slower and easier to manuver
		motor[BR] = -30;
  }else if(vexRT[Ch2] < -100){
		motor[FR] = 30;
		motor[BR] = 30;
  }else{
  	motor[FR] = 0;
		motor[BR] = 0;
  }


  //Driving for Ch3 axis
  if(vexRT[Ch3] > 100){
		motor[FL] = 30;//The motor power is 60 so the bot is slower and easier to manuver
		motor[BL] = 30;
  }else if(vexRT[Ch3] < -100){
		motor[FL] = -30;
		motor[BL] = -30;
  }else{
  	motor[FL] = 0;
		motor[BL] = 0;
  }



  //If 8U or 8D is pressed moves BS which is the bar spinner
	 if(vexRT[Btn8U] == 1){
   	 motor[BS] = 30;
 	 }else if(vexRT[Btn8D] == 1){
  		motor[BS] = -30;
 	 }else{
 	  motor[BS] = 0;
   }//end if else



   //Increases to count how many iterations through the while loop
	 iterations ++;


	 //These check if the state of a button has changed since the last iteration
	 if(up8U != vexRT[Btn8U]){
	 	 change = true;
   }

	 if(up8D != vexRT[Btn8D]){
	 	 change = true;
   }

   //These check for the axis of they have changed state
   if(upCh3 != (vexRT[Ch3] > 100)){
	   change = true;
   }

   if(downCh3 != (vexRT[Ch3] < -100)){
	   change = true;
   }

	 if(upCh2 != (vexRT[Ch2] > 100)){
	   change = true;
   }

   if(downCh2 != (vexRT[Ch2] < -100)){
	   change = true;
   }

   //If change is true
   if(change){
    writeDebugStream("%d,", SensorValue[sBS]);
    writeDebugStream("%d,", nMotorEncoder(FL));
		writeDebugStream("%d,", nMotorEncoder(FR));
		writeDebugStream("%d,", nMotorEncoder(BL));
		writeDebugStreamLine("%d", nMotorEncoder(BR));

    change = false;
   }

   //Changes what the state varibles are
   up8U = vexRT[Btn8U];
   up8D = vexRT[Btn8D];

   //So that if the axis do change form up to down or down to up, You don't need more if statements to track the change, just to see what it currently is
   upCh3 = false;
	 downCh3 = false;
	 upCh2 = false;
	 downCh2 = false;

   if(vexRT[Ch3] > 100){
   	upCh3 = true;
   }
   if(vexRT[Ch3] < -100){
   	downCh3 = true;
   }

   if(vexRT[Ch2] > 100){
   	upCh2 = true;
   }
   if(vexRT[Ch2] < -100){
   	downCh2 = true;
   }

  }//While


}//User control
