//This code is in the init.c file
/** @file init.c
 * @brief File for initialization code
 *
 * This file should contain the user initialize() function and any functions related to it.
 *
 * Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/publicdomain/zero/1.0/
 *
 * PROS contains FreeRTOS (http://www.freertos.org) whose source code may be
 * obtained from http://sourceforge.net/projects/freertos/files/ or on request.
 */

#include "main.h"
#include "ports.c"
/*
 * Runs pre-initialization code. This function will be started in kernel mode one time while the
 * VEX Cortex is starting up. As the scheduler is still paused, most API functions will fail.
 *
 * The purpose of this function is solely to set the default pin modes (pinMode()) and port
 * states (digitalWrite()) of limit switches, push buttons, and solenoids. It can also safely
 * configure a UART port (usartOpen()) but cannot set up an LCD (lcdInit()).
 */
void initializeIO() {
}

/*
 * Runs user initialization code. This function will be started in its own task with the default
 * priority and stack size once when the robot is starting up. It is possible that the VEXnet
 * communication link may not be fully established at this time, so reading from the VEX
 * Joystick may fail.
 *
 * This function should initialize most sensors (gyro, encoders, ultrasonics), LCDs, global
 * variables, and IMEs.
 *
 * This function must exit relatively promptly, or the operatorControl() and autonomous() tasks
 * will not start. An autonomous mode selection menu like the pre_auton() in other environments
 * can be implemented in this task if desired.
 */
void initialize() {

  int test = imeInitializeAll();
    if(test != 4){
      while(1)
        print("error");
    }

  imeReset(sensorFL);
  imeReset(sensorFR);
  imeReset(sensorBL);
  imeReset(sensorBR);
  encoderReset(sensorBS);
    /*while(1)
      print("done");*/
  sensorBS = encoderInit(sensorBStop, sensorBSbot, false);

}



//This code is in a file named ports.c located in the include folder
//Motor ports
#define BS 1
#define FL 2
#define FR 3
#define BL 4
#define BR 5

//Sensor Points
#define sensorFL 1
#define sensorFR 0
#define sensorBL 2
#define sensorBR 3
#define sensorBStop 1
#define sensorBSbot 2



//This code is in the main.h file
/** @file main.h
 * @brief Header file for global functions
 *
 * Any experienced C or C++ programmer knows the importance of header files. For those who
 * do not, a header file allows multiple files to reference functions in other files without
 * necessarily having to see the code (and therefore causing a multiple definition). To make
 * a function in "opcontrol.c", "auto.c", "main.c", or any other C file visible to the core
 * implementation files, prototype it here.
 *
 * This file is included by default in the predefined stubs in each VEX Cortex PROS Project.
 *
 * Copyright (c) 2011-2016, Purdue University ACM SIGBots.
 * All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * PROS contains FreeRTOS (http://www.freertos.org) whose source code may be
 * obtained from http://sourceforge.net/projects/freertos/files/ or on request.
 */

#ifndef MAIN_H_

// This prevents multiple inclusion, which isn't bad for this file but is good practice
#define MAIN_H_

#include <API.h>

// Allow usage of this file in C++ programs
#ifdef __cplusplus
extern "C" {
#endif

// A function prototype looks exactly like its declaration, but with a semicolon instead of
// actual code. If a function does not match a prototype, compile errors will occur.

// Prototypes for initialization, operator control and autonomous

Encoder sensorBS;



/**
 * Runs the user autonomous code. This function will be started in its own task with the default
 * priority and stack size whenever the robot is enabled via the Field Management System or the
 * VEX Competition Switch in the autonomous mode. If the robot is disabled or communications is
 * lost, the autonomous task will be stopped by the kernel. Re-enabling the robot will restart
 * the task, not re-start it from where it left off.
 *
 * Code running in the autonomous task cannot access information from the VEX Joystick. However,
 * the autonomous function can be invoked from another task if a VEX Competition Switch is not
 * available, and it can access joystick information if called in this way.
 *
 * The autonomous task may exit, unlike operatorControl() which should never exit. If it does
 * so, the robot will await a switch to another mode or disable/enable cycle.
 */
void autonomous();
/**
 * Runs pre-initialization code. This function will be started in kernel mode one time while the
 * VEX Cortex is starting up. As the scheduler is still paused, most API functions will fail.
 *
 * The purpose of this function is solely to set the default pin modes (pinMode()) and port
 * states (digitalWrite()) of limit switches, push buttons, and solenoids. It can also safely
 * configure a UART port (usartOpen()) but cannot set up an LCD (lcdInit()).
 */
void initializeIO();
/**
 * Runs user initialization code. This function will be started in its own task with the default
 * priority and stack size once when the robot is starting up. It is possible that the VEXnet
 * communication link may not be fully established at this time, so reading from the VEX
 * Joystick may fail.
 *
 * This function should initialize most sensors (gyro, encoders, ultrasonics), LCDs, global
 * variables, and IMEs.
 *
 * This function must exit relatively promptly, or the operatorControl() and autonomous() tasks
 * will not start. An autonomous mode selection menu like the pre_auton() in other environments
 * can be implemented in this task if desired.
 */
void initialize();
/**
 * Runs the user operator control code. This function will be started in its own task with the
 * default priority and stack size whenever the robot is enabled via the Field Management System
 * or the VEX Competition Switch in the operator control mode. If the robot is disabled or
 * communications is lost, the operator control task will be stopped by the kernel. Re-enabling
 * the robot will restart the task, not resume it from where it left off.
 *
 * If no VEX Competition Switch or Field Management system is plugged in, the VEX Cortex will
 * run the operator control task. Be warned that this will also occur if the VEX Cortex is
 * tethered directly to a computer via the USB A to A cable without any VEX Joystick attached.
 *
 * Code running in this task can take almost any action, as the VEX Joystick is available and
 * the scheduler is operational. However, proper use of delay() or taskDelayUntil() is highly
 * recommended to give other tasks (including system tasks such as updating LCDs) time to run.
 *
 * This task should never exit; it should end with some kind of infinite loop, even if empty.
 */
void operatorControl();

// End C++ export structure
#ifdef __cplusplus
}
#endif

#endif



//This code is in the auto.c file
/** @file auto.c
 * @brief File for autonomous code
 *
 * This file should contain the user autonomous() function and any functions related to it.
 *
 * Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/publicdomain/zero/1.0/
 *
 * PROS contains FreeRTOS (http://www.freertos.org) whose source code may be
 * obtained from http://sourceforge.net/projects/freertos/files/ or on request.
 */

#include "main.h"
#include "ports.c"
/*
 * Runs the user autonomous code. This function will be started in its own task with the default
 * priority and stack size whenever the robot is enabled via the Field Management System or the
 * VEX Competition Switch in the autonomous mode. If the robot is disabled or communications is
 * lost, the autonomous task will be stopped by the kernel. Re-enabling the robot will restart
 * the task, not re-start it from where it left off.
 *
 * Code running in the autonomous task cannot access information from the VEX Joystick. However,
 * the autonomous function can be invoked from another task if a VEX Competition Switch is not
 * available, and it can access joystick information if called in this way.
 *
 * The autonomous task may exit, unlike operatorControl() which should never exit. If it does
 * so, the robot will await a switch to another mode or disable/enable cycle.
 */
 bool compare(int base, int comp){

 	bool same = false;

 	if(comp > (base - 10) && comp < (base + 10)){

 		same = true;
 	}//if


 	return same;
 }//compare



void autonomous() {
  //What step of the recording code is happening
  int step = 0;
  //The axel positions of every step
  int autostep[5][5] = { {0,1000,-1000,1000,-1000},
   {20,1000,-1000,1000,-1000},
   {-20,1000,-1000,1000,-1000},
   {0,1000,-1000,1000,-1000},
   {0,0,0,0,0}
  };
  //How many steps there are in the autonomus
  int totalSteps = 5;
  //How many motors are involved
  int motors = 4;
  //Is compared to total motors so the code can know when all motors are done
  int motorsDone = 0;

  //FL motor varibles
  //If FL has finished the step or not and the axel postion
  bool FLdone = false;
  int FLcounts = 0;

  //FL motor varibles
  //If FR has finished the step or not and the axel postion
  bool FRdone = false;
  int FRcounts = 0;

  //FL motor varibles
  //If BL has finished the step or not and the axel postion
  bool BLdone = false;
  int BLcounts = 0;

  //FL motor varibles
  //If BR has finished the step or not and the axel postion
  bool BRdone = false;
  int BRcounts = 0;


  int counts = 0;


  //This continues while there are still steps left
  while(step != totalSteps ){

    //This continues untill all motors are done
    while(motors != motorsDone){

      //FL if
      if(!FLdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(autostep[step][1], FLcounts)){
          //Stops motor
          motorSet(FL, 0);
          //Says this motor is done to prevent entering this loop and creating a false positive
          FLdone = true;
          //Increases total of motors done
          motorsDone++;
          //Breaks out of this if so the motor doesn't restart
          goto FLend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(FLcounts > autostep[step][1]){
          motorSet(FL, -30);
          //If the target value os above the motor value it will spin foreward
        }else if(FLcounts < autostep[step][1]){
          motorSet(FL, 30);
        }

        //Where the goto comes to
        FLend:;

      }//FL if







      //FR if
      if(!FRdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(autostep[step][2], FRcounts)){
          //Stops motor
          motorSet(FR, 0);
          //Says this motor is done to prevent entering this loop and creating a false positive
          FRdone = true;
          //Increases total of motors done
          motorsDone++;
          //Breaks out of this if so the motor doesn't restart
          goto FRend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(FRcounts > autostep[step][2]){
          motorSet(FR, -30);
          //If the target value os above the motor value it will spin foreward
        }else if(FRcounts < autostep[step][2]){
          motorSet(FR, 30);
        }

        //Where the goto comes to
        FRend:;

      }//FR if







      //BR if
      if(!BLdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(autostep[step][3], BLcounts)){
          //Stops motor
          motorSet(BL, 0);
          //Says this motor is done to prevent entering this loop and creating a false positive
          BLdone = true;
          //Increases total of motors done
          motorsDone++;
          //Breaks out of this if so the motor doesn't restart
          goto BLend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(BLcounts > autostep[step][3]){
          motorSet(BL, -30);
          //If the target value os above the motor value it will spin foreward
        }else if(BLcounts < autostep[step][3]){
          motorSet(BL, 30);
        }

        //Where the goto comes to
        BLend:;

      }//BL if






      //BR if
      if(!BRdone){

        //Checks to see if the motor value matches the target value and if it does
        if(compare(autostep[step][4], BRcounts)){
          //Stops motor
          motorSet(BR, 0);
          //Says this motor is done to prevent entering this loop and creating a false positive
          BRdone = true;
          //Increases total of motors done
          motorsDone++;
          //Breaks out of this if so the motor doesn't restart
          goto BRend;

          //If the target value is below the actual value the motor will spin backwards
        }else if(BRcounts > autostep[step][4]){
          motorSet(BR, -30);
          //If the target value os above the motor value it will spin foreward
        }else if(BRcounts < autostep[step][4]){
          motorSet(BR, 30);
        }

        //Where the goto comes to
        BRend:;

      }//BR if

      if(counts == 3000){

        printf("Step: %d", step);
        printf("Motors Done: %d", motorsDone);
        counts = 0;


      }


      counts ++;

      //Updates the sensor values
      imeGet(sensorFL, &FLcounts);
      imeGet(sensorFR, &FRcounts);
      imeGet(sensorBL, &BLcounts);
      imeGet(sensorBR, &BRcounts);
    }//Inner while

    motorsDone = 0;
    FLdone = false;
    FRdone = false;
    BLdone = false;
    BRdone = false;
    step++;

  }//Outer while





}



//This code is in the opcontrol.c file
/** @file opcontrol.c
 * @brief File for operator control code
 *
 * This file should contain the user operatorControl() function and any functions related to it.
 *
 * Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/publicdomain/zero/1.0/
 *
 * PROS contains FreeRTOS (http://www.freertos.org) whose source code may be
 * obtained from http://sourceforge.net/projects/freertos/files/ or on request.
 */

#include "main.h"
#include "ports.c"
/*
 * Runs the user operator control code. This function will be started in its own task with the
 * default priority and stack size whenever the robot is enabled via the Field Management System
 * or the VEX Competition Switch in the operator control mode. If the robot is disabled or
 * communications is lost, the operator control task will be stopped by the kernel. Re-enabling
 * the robot will restart the task, not resume it from where it left off.
 *
 * If no VEX Competition Switch or Field Management system is plugged in, the VEX Cortex will
 * run the operator control task. Be warned that this will also occur if the VEX Cortex is
 * tethered directly to a computer via the USB A to A cable without any VEX Joystick attached.
 *
 * Code running in this task can take almost any action, as the VEX Joystick is available and
 * the scheduler is operational. However, proper use of delay() or taskDelayUntil() is highly
 * recommended to give other tasks (including system tasks such as updating LCDs) time to run.
 *
 * This task should never exit; it should end with some kind of infinite loop, even if empty.
 */
void operatorControl() {


	//Joy Stick
	int ax2 = 0;
	int ax3 = 0;
	int up8 = 0;
	int dn8 = 0;

	//Varibles to store axel positions of motors
	int BScounts = 0;
	int FLcounts = 0;
	int FRcounts = 0;
	int BLcounts = 0;
	int BRcounts = 0;

	//Varible to hold counts so that the sensor output is delayed and can be read
	int counts = 0;

	while (1) {

			//Updating joystick varibles
			/*ax2 = joystickGetAnalog(1, 2);
			ax3 = joystickGetAnalog(1, 3);*/
			//These if statemnts are used so that the speed of the bot does not need to be a factor in the recording
			//either the motors are all the way on, or theyre all the way off
			if(joystickGetAnalog(1, 2) > 100){
				ax2 = 127;
			}else if(joystickGetAnalog(1, 2) < -100){
				ax2 = -127;
			}else{
				ax2 = 0;
			}
			if(joystickGetAnalog(1, 3) > 100){
				ax3 = 127;
			}else if(joystickGetAnalog(1, 3) < -100){
				ax3 = -127;
			}else{
				ax3 = 0;
			}
			up8 = joystickGetDigital(1, 8, JOY_UP);
			dn8 = joystickGetDigital(1, 8, JOY_DOWN);

			//Setting drive train motors
			motorSet(FL, ax3);
			motorSet(BL, ax3);
			motorSet(FR, -ax2);
			motorSet(BR, -ax2);


			//Setting bar spinning motor
			if(up8){

				motorSet(BS, 30);
			}else if(dn8){

				motorSet(BS, -30);
			}else{

				motorSet(BS, 0);
			}

			//Change axel position varibles
    	imeGet(sensorFL, &FLcounts);
			imeGet(sensorFR, &FRcounts);
			imeGet(sensorBL, &BLcounts);
			imeGet(sensorBR, &BRcounts);
			BScounts = encoderGet(sensorBS);


  }//While


}//End of method

